
 + 상속, Inheritance
 	
	- 목적 : 클래스 코드의 재사용

  	- 기존의 클래스 코드를 재사용하여 새로운 클래스를 작성할 수 있게 해주는 문법

	** 코드의 재사용 **

	기존의 코드를 이용하여 새로운 코드를 개발하는 것
	( 필요한 부분은 수정하고, 추가하기도 한다 )

  	- 클래스의 중복되는 코드를 하나의 클래스로 관리할 수 있게 해준다.

  	- 상속을 주는 클래스의 코드를 변경하면 상속을 받는 클래스들 전부 반영된다.

  	- 상속을 주는 클래스 : 부모, 수퍼, 상위, Based(기준이 되는)

  	- 상속을 받는 클래스 : 자식, 서브, 하위, Derived(유도된, 파생된)


  + 상속의 문법

	class Parent {
	  int n1;
	  int n2;
	  String name;
	}

	class Child extends Parent {
	
	}

	Child 클래스는 Parent 클래스의 멤버필드를 상속받음
	Child 클래스는 필드를 선언하지 않았지만 가지고 있는 것 처럼 사용할 수 있음




  + 메소드 오버로딩(Overloading) //불러온다.

	- 메소드 중복정의


	- 같은 이름의 메소드를 매개변수의 개수나 타입을 다르게 하여 
	  다른 메소드를 정의하는것


  + 메소드 오버라이딩(overriding) //덮어씌운다.

	- 메소드 재정의

	- 상속받은 메소드를 자식클래스가 새롭게 정의하는 것

  + 바인딩, Binding
  
  	- 메소드의 호출코드와 메소드의 정의코드(구현코드)를 연결하는 과정

		ex)	public void out() {
			System.out.println("Test");
		}
		
		test.out();

	- 정적 바인딩 : 컴파일 시점에 바인딩한다.
	
	- 동적 바인딩 : 실행 도중에 메소드가 호출될 때 바인딩한다.

	** 자바는 기본적으로 동적 바인딩을 한다 **

	
  + Super 키워드
  
  	- super
	 식클래스에서 부모클래스의 멤버에 접근할 때 사용한다.

	 자식클래스에서 정의한 이름(식별자)와 상속받은 부모클래스의 이름(식별자)가 중복될 때 구분하기 위해 사용할 수 있다.

	 ex )	this.num =10; //자식클래스에서 정의한 멤버필드 num
		super.num =20; //부모클래스에서 정의한 멤버필드 num
		
		
		//오버라이딩이 되어있는 경우
		this.display(); //오버라이딩한 메소드
		super.display(); //오버라이딩 전 부모 메소드
		
	- super()
		
		수퍼 생성자 호출

		자식클래스의 생성자에서 부모클래스의 생성자를 호출할 때 사용
		
		전달인자를 넣어 사용 가능하다.
		(부모클래스에 정의되어있을 때에만 가능하다.)
		
		따로 호출하지 않으면 부모클래스의 디폴트생성자를 자동으로 호출한다.

		자식클래스의 생성자에서 첫 번째 코드로 사용해야 한다.


	 + final 키워드

		- 더 이상 확장할 수 없도록 설정하는 키워드

	 + final 키워드 적용 위치

		- 변수
		
		딱 한번만 초기화(대입)할 수 있도록 설정한다.

		변수를 상수화시킨다.

		ex)	public final int MAX = 5;
			public static final int LEN = 10;
	

		- 메소드
		
		더 이상 오버라이딩할 수 없도록 설정

		ex)	public final void out() {
		//자식 클래스에서 재정의 불가
		}
		
		
		
		- 클래스

		더 이상 자식클래스를 생성할 수 없도록 설정

		ex)	public final class Child {
		//자식클래스를 만들 수 없음
		//상속을 줄 수 없게 만듦
		}

